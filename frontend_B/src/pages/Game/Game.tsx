// frontend_B/src/pages/Game/Game.tsx
import React, { useState, useEffect } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { gameAPI } from '../../services/api';
import { useUser } from '../../contexts/UserContext';
import PongGame from '../../components/PongGame/PongGame';
import './Game.css';

interface GameData {
  id: string;
  players: Array<{
    id: string;
    username: string;
    avatar: string;
  }>;
  score: {
    player1: number;
    player2: number;
  };
  status: 'waiting' | 'playing' | 'finished';
  spectatorCount: number;
}

const Game: React.FC = () => {
  const { gameId } = useParams<{ gameId: string }>();
  const navigate = useNavigate();
  const { loadStats } = useUser();
  const [gameData, setGameData] = useState<GameData | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [chatMessage, setChatMessage] = useState('');
  const [messages, setMessages] = useState<any[]>([]);
  const [gameEnded, setGameEnded] = useState(false);
  const [gameResult, setGameResult] = useState<{ winner: string; finalScore: any; playerNames?: any } | null>(null);
  const [playerNames, setPlayerNames] = useState<{ player1: string; player2: string }>({ player1: 'Joueur 1', player2: 'Joueur 2' });
  const [rematchRequest, setRematchRequest] = useState<{ fromPlayer: string; fromName: string } | null>(null);
  const [waitingForRematch, setWaitingForRematch] = useState(false);
  const [currentSocketId, setCurrentSocketId] = useState<string | null>(null);

  // Fonction pour g√©n√©rer une couleur bas√©e sur le nom d'utilisateur
  const getUserColor = (username: string): string => {
    const colors = [
      '#FF6B6B', // Rouge
      '#4ECDC4', // Turquoise
      '#45B7D1', // Bleu
      '#96CEB4', // Vert
      '#FFEAA7', // Jaune
      '#DDA0DD', // Violet clair
      '#98D8C8', // Menthe
      '#F7DC6F', // Or
      '#BB8FCE', // Lavande
      '#85C1E9', // Bleu clair
      '#F8C471', // Orange
      '#82E0AA', // Vert clair
    ];

    // G√©n√©rer un hash simple du nom d'utilisateur
    let hash = 0;
    for (let i = 0; i < username.length; i++) {
      hash = username.charCodeAt(i) + ((hash << 5) - hash);
    }

    // Utiliser le hash pour s√©lectionner une couleur
    const colorIndex = Math.abs(hash) % colors.length;
    return colors[colorIndex];
  };

  useEffect(() => {
    const fetchGameData = async () => {
      if (!gameId) return;

      try {
        setIsLoading(true);
        // Pour les parties rapides, pas besoin d'appeler l'API
        // Les donn√©es sont g√©r√©es par WebSocket
        if (gameId.startsWith('game_') || gameId.startsWith('quick_')) {
          setGameData({
            id: gameId,
            players: [],
            score: { player1: 0, player2: 0 },
            status: 'waiting',
            spectatorCount: 0
          });
        } else if (gameId.startsWith('tournament_')) {
          // Pour les matchs de tournoi
          const matchId = gameId.replace('tournament_', '');
          console.log('üéÆ Loading tournament match:', { gameId, matchId });
          
          const response = await gameAPI.getMatch(parseInt(matchId));
          const match = response.data;
          
          console.log('üéÆ Tournament match data:', match);
          
          // V√©rifier que match a les bonnes propri√©t√©s
          if (!match || !match.player1 || !match.player2) {
            throw new Error('Donn√©es de match incompl√®tes');
          }
          
          // Adapter le format du match au format attendu par la page Game
          setGameData({
            id: gameId,
            players: [
              {
                id: match.player1.id.toString(),
                username: match.player1.username,
                avatar: match.player1.avatar || 'üë§'
              },
              {
                id: match.player2.id.toString(),
                username: match.player2.username,
                avatar: match.player2.avatar || 'üë§'
              }
            ],
            score: { 
              player1: match.player1Score || 0, 
              player2: match.player2Score || 0 
            },
            status: match.status === 'active' ? 'playing' : (match.status === 'finished' ? 'finished' : 'waiting'),
            spectatorCount: 0
          });
          
          // Mettre √† jour les noms des joueurs
          setPlayerNames({
            player1: match.player1.username,
            player2: match.player2.username
          });
          
          console.log('‚úÖ Tournament match loaded successfully');
        } else {
          // Pour les matchs existants (ID num√©rique)
          const response = await gameAPI.getGame(gameId);
          setGameData(response.data);
        }
      } catch (err: any) {
        setError(err.response?.data?.message || 'Erreur de chargement');
      } finally {
        setIsLoading(false);
      }
    };

    fetchGameData();
  }, [gameId]);

  const handleSendMessage = () => {
    if (!chatMessage.trim()) return;

    // Envoyer via WebSocket
    if ((window as any).sendChatMessage) {
      (window as any).sendChatMessage(chatMessage);
    }
    setChatMessage('');
  };

  const handleChatMessage = (messageData: { username: string; message: string; timestamp: string; senderId: string }) => {
    console.log('üí¨ GAME: Message de chat re√ßu:', messageData);
    setMessages(prev => [...prev, {
      username: messageData.username,
      message: messageData.message,
      timestamp: new Date(messageData.timestamp),
      senderId: messageData.senderId,
      isOwnMessage: messageData.senderId === currentSocketId
    }]);
  };

  const handleSocketId = (socketId: string) => {
    setCurrentSocketId(socketId);
  };

  const handleGameEnd = (winner: 'player1' | 'player2', finalScore: any, receivedPlayerNames: any) => {
    setGameEnded(true);
    setGameResult({ winner, finalScore, playerNames: receivedPlayerNames });
    setPlayerNames(receivedPlayerNames);

    // Rafra√Æchir les statistiques du joueur apr√®s la partie
    console.log('üîÑ GAME: Rafra√Æchissement des stats apr√®s fin de partie');
    loadStats().catch(err => {
      console.warn('‚ö†Ô∏è GAME: Erreur lors du rafra√Æchissement des stats:', err);
    });
  };

  const handleQuitGame = () => {
    if (confirm('√ätes-vous s√ªr de vouloir quitter la partie ?')) {
      navigate('/');
    }
  };

  // Fonctions pour le menu de fin de partie
  const handleNewGame = async () => {
    try {
      console.log('üéÆ GAME: Cr√©ation d\'une nouvelle partie');
      const response = await gameAPI.createQuickMatch();
      const newGameId = response.data.gameId;
      console.log('üéÆ GAME: Nouvelle partie cr√©√©e:', newGameId);
      navigate(`/game/${newGameId}`);
    } catch (error) {
      console.error('üî¥ GAME: Erreur lors de la cr√©ation d\'une nouvelle partie:', error);
      alert('Impossible de cr√©er une nouvelle partie. Veuillez r√©essayer.');
    }
  };

  const handleRematch = () => {
    console.log('üîÑ GAME: Demande de rematch envoy√©e');
    setWaitingForRematch(true);
    // Appel de la fonction depuis le composant PongGame
    if ((window as any).sendRematchRequest) {
      (window as any).sendRematchRequest();
    }
  };

  const handleAcceptRematch = () => {
    console.log('‚úÖ GAME: Rematch accept√©');
    setRematchRequest(null);
    // Appel de la fonction depuis le composant PongGame
    if ((window as any).sendAcceptRematch) {
      (window as any).sendAcceptRematch();
    }
  };

  const handleDeclineRematch = () => {
    console.log('‚ùå GAME: Rematch refus√©');
    setRematchRequest(null);
    setWaitingForRematch(false);
    // Appel de la fonction depuis le composant PongGame
    if ((window as any).sendDeclineRematch) {
      (window as any).sendDeclineRematch();
    }
  };

  const handleRematchRequested = (data: { fromPlayer: string; fromName: string }) => {
    console.log('üîî GAME: Demande de rematch re√ßue:', data);
    setRematchRequest(data);
  };

  const handleRematchStarted = () => {
    console.log('üîÑ GAME: Rematch d√©marr√©');
    setGameEnded(false);
    setGameResult(null);
    setRematchRequest(null);
    setWaitingForRematch(false);
  };

  const handleRematchDeclined = () => {
    console.log('‚ùå GAME: Rematch refus√© par l\'adversaire');
    setRematchRequest(null);
    setWaitingForRematch(false);
  };

  const handleQuitToHome = () => {
    navigate('/');
  };

  const handlePlayerNamesUpdate = (updatedPlayerNames: any) => {
    setPlayerNames(updatedPlayerNames);
  };

  if (isLoading) {
    return (
      <div className="game-loading">
        <div className="loading-icon">‚è≥</div>
        <p>Chargement de la partie...</p>
      </div>
    );
  }

  if (error || !gameData || !gameData.score || !playerNames) {
    return (
      <div className="game-error">
        <div className="error-icon">‚ö†Ô∏è</div>
        <p className="error-message">{error || 'Partie introuvable'}</p>
        <p style={{ fontSize: '0.8rem', color: '#666' }}>
          Debug: gameData={!!gameData}, score={!!gameData?.score}, playerNames={!!playerNames}
        </p>
      </div>
    );
  }

  return (
    <div className="game-page">
      <div className="game-header">
        <div className="container">
          <div className="game-header-content">
            <h1 className="game-title">üèì Partie Pong</h1>
            
            <div className="game-score">
              <div className="player-score">
                <div className="player-name">{playerNames.player1}</div>
                <div className="score-value">{gameData.score.player1}</div>
              </div>
              <div className="score-vs">VS</div>
              <div className="player-score">
                <div className="player-name">{playerNames.player2}</div>
                <div className="score-value">{gameData.score.player2}</div>
              </div>
            </div>

            <div className="game-header-actions">
              <button className="btn btn-secondary">‚öôÔ∏è</button>
              <button className="btn btn-danger" onClick={handleQuitGame}>üö™ Quitter</button>
            </div>
          </div>
        </div>
      </div>

      <div className="container">
        <div className="game-layout">
          
          <div className="card game-area">
            <div id="game-canvas-container" className="game-canvas">
              {gameId ? (
                <PongGame
                  gameId={gameId}
                  onGameEnd={handleGameEnd}
                  onPlayerNamesUpdate={handlePlayerNamesUpdate}
                  onRematchRequest={handleRematch}
                  onRematchRequested={handleRematchRequested}
                  onRematchStarted={handleRematchStarted}
                  onRematchDeclined={handleRematchDeclined}
                  onAcceptRematch={handleAcceptRematch}
                  onDeclineRematch={handleDeclineRematch}
                  waitingForRematch={waitingForRematch}
                  onChatMessage={handleChatMessage}
                  onSocketId={handleSocketId}
                />
              ) : (
                <div className="game-placeholder">
                  <div className="game-placeholder-icon">üéÆ</div>
                  <div className="game-placeholder-title">Aucun ID de partie fourni</div>
                  <div className="game-placeholder-subtitle">
                    Retournez √† l'accueil pour cr√©er une partie
                  </div>
                </div>
              )}
            </div>
          </div>

          <div className="game-sidebar">
            <div className="card game-players">
              <h3 className="sidebar-title">üë• Joueurs</h3>
              {gameData.players.map((player) => (
                <div key={player.id} className="player-item">
                  <span className="player-avatar">{player.avatar || 'üòÄ'}</span>
                  <span className="player-username">{player.username}</span>
                </div>
              ))}
            </div>

            <div className="card game-spectators">
              <h3 className="sidebar-title">
                üëÄ Spectateurs ({gameData.spectatorCount})
              </h3>
            </div>

            <div className="card game-chat">
              <h3 className="sidebar-title">üí¨ Chat</h3>
              
              <div className="chat-messages">
                {messages.length === 0 ? (
                  <div className="chat-empty">
                    Aucun message
                  </div>
                ) : (
                  messages.map((msg, index) => {
                    const userColor = msg.isOwnMessage ? '#9932CC' : getUserColor(msg.username);
                    const messageStyle = msg.isOwnMessage
                      ? { borderLeftColor: userColor }
                      : { borderLeftColor: userColor, backgroundColor: `${userColor}15` };

                    return (
                      <div
                        key={index}
                        className={`chat-message ${msg.isSystem ? 'system-message' : ''} ${msg.isOwnMessage ? 'own-message' : 'other-message'}`}
                        style={messageStyle}
                      >
                        <strong
                          className="chat-username"
                          style={{ color: userColor }}
                        >
                          {msg.isOwnMessage ? 'Moi' : msg.username}:
                        </strong>{' '}
                        <span className="chat-text">{msg.message}</span>
                      </div>
                    );
                  })
                )}
              </div>

              <div className="chat-input">
                <input
                  type="text"
                  className="input"
                  placeholder="Message..."
                  value={chatMessage}
                  onChange={(e) => setChatMessage(e.target.value)}
                  onKeyPress={(e) => e.key === 'Enter' && handleSendMessage()}
                />
                <button 
                  className="btn btn-primary chat-send"
                  onClick={handleSendMessage}
                >
                  üì§
                </button>
              </div>
            </div>
          </div>
        </div>

        {/* Menu de fin de partie */}
        {gameEnded && gameResult && (
          <div className="game-end-overlay">
            <div className="game-end-menu">
              <div className="game-end-header">
                <h2 className="game-end-title">
                  {gameResult.winner === 'player1'
                    ? (gameResult.playerNames?.player1 || 'Joueur 1')
                    : (gameResult.playerNames?.player2 || 'Joueur 2')
                  } a gagn√©!
                </h2>
                <div className="game-end-score">
                  Score final: {gameResult.finalScore.player1} - {gameResult.finalScore.player2}
                </div>
              </div>

              <div className="game-end-actions">
                <button
                  className="btn btn-primary btn-large game-end-btn"
                  onClick={handleNewGame}
                >
                  üéÆ Nouvelle partie
                </button>
                <button
                  className="btn btn-secondary btn-large game-end-btn"
                  onClick={handleRematch}
                  disabled={waitingForRematch}
                >
                  {waitingForRematch ? '‚è≥ En attente...' : 'üîÑ Rejouer'}
                </button>
                <button
                  className="btn btn-danger btn-large game-end-btn"
                  onClick={handleQuitToHome}
                >
                  üö™ Quitter
                </button>
              </div>
            </div>
          </div>
        )}

        {/* Demande de rematch re√ßue */}
        {rematchRequest && (
          <div className="game-end-overlay">
            <div className="game-end-menu rematch-request">
              <div className="game-end-header">
                <h2 className="game-end-title">
                  üîî Demande de rematch
                </h2>
                <div className="rematch-message">
                  <strong>{rematchRequest.fromName}</strong> souhaite faire un rematch.
                  <br />
                  Acceptez-vous de rejouer ?
                </div>
              </div>

              <div className="game-end-actions">
                <button
                  className="btn btn-primary btn-large game-end-btn"
                  onClick={handleAcceptRematch}
                >
                  ‚úÖ Accepter
                </button>
                <button
                  className="btn btn-danger btn-large game-end-btn"
                  onClick={handleDeclineRematch}
                >
                  ‚ùå Refuser
                </button>
              </div>
            </div>
          </div>
        )}

      </div>
    </div>
  );
};

export default Game;